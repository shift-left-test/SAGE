import os
import subprocess
import hashlib
import logging

from .tool_wrapper import *

MAKEFILE = "Makefile"
COMPILE_DB_MARKER = ".compiledb_mark"
SAGE_COMPILE_COMMANDS_JSON = "sage_compile_commands.json"

BUF_SIZE = 65536

logger = logging.getLogger('SAGE')

def _get_hash(file):
    sha1 = hashlib.sha1()

    with open(file) as f:
        while True:
            data = f.read(BUF_SIZE)
            if not data:
                break
            sha1.update(data)

    return sha1.hexdigest()


def _remove_file(file):
    if os.path.isfile(file):
        os.remove(file)


def _create_compile_commands(ctx):
    if not os.path.isfile(os.path.join(ctx.work_path, MAKEFILE)):
        logger.warning("can't generage compile_commands.json without Makefile")
        return

    _remove_file(os.path.join(ctx.work_path, ctx.proj_file))
    _remove_file(os.path.join(ctx.work_path, SAGE_COMPILE_COMMANDS_JSON))
    _remove_file(os.path.join(ctx.work_path, COMPILE_DB_MARKER))

    # generage SAGE_COMPILE_COMMANDS_JSON
    subprocess.call(["compiledb", "--command-style", "--output", SAGE_COMPILE_COMMANDS_JSON, "make"], cwd=ctx.work_path)

    # create COMPILE_DB_MARKER
    with open(os.path.join(ctx.work_path, COMPILE_DB_MARKER), "w") as f:
        f.write(_get_hash(os.path.join(ctx.work_path, SAGE_COMPILE_COMMANDS_JSON)))

    # rename SAGE_COMPILE_COMMANDS_JSON to ctx.proj_file
    os.rename(os.path.join(ctx.work_path, SAGE_COMPILE_COMMANDS_JSON), os.path.join(ctx.work_path, ctx.proj_file))



def generate_compile_commands(ctx):
    # check "compile_commands.json" exist  
    if os.path.isfile(os.path.join(ctx.work_path, ctx.proj_file)):
        if os.path.isfile(os.path.join(ctx.work_path, COMPILE_DB_MARKER)):
            hash = _get_hash(os.path.join(ctx.work_path, ctx.proj_file))
            with open(os.path.join(ctx.work_path, COMPILE_DB_MARKER)) as f:
                if f.read() == hash:
                    logger.info("SHA is identical!!! Will be regenerated.")
                else:
                    logger.warning("SHA is different!!! 'compile_commands.json' is generated by other tool.")
                    # hash is different so compile_commands.json is not generated by sage.
                    return
        else:
            # this compile_commands.json is not generaged by sage. so don't touch
            return

    _create_compile_commands(ctx)


def run_check_tools(ctx):
    for tool in ctx.tool_list:
        if get_tool_executable(tool) is None:
            logger.warning("* {} is not installed!!!".format(tool))
            continue
        logger.info("* {} is running...".format(tool))
        wrapper = get_tool_wrapper(tool)(ctx)
        wrapper.run()